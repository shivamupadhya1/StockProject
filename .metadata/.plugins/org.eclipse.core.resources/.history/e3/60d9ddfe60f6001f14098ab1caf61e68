package com.stock.in.service;

import com.stock.in.dto.StockDTO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

@Slf4j
@Service
public class StockService {
    private final RestTemplate restTemplate = new RestTemplate();
    
    @Value("${alphavantage.api.key}")
    private String apiKey;  // Injected from application.properties

    // Store multiple stock queues for different symbols
    private final Map<String, Queue<StockDTO>> stockData = new ConcurrentHashMap<>();

    @Scheduled(fixedRate = 300000) // Fetch every 5 minutes
    public void fetchStockPrices() {
        List<String> stockSymbols = Arrays.asList("DJI", "AAPL", "GOOGL"); // Add more symbols if needed

        for (String symbol : stockSymbols) {
            fetchStockPrice(symbol);
        }
    }

    private void fetchStockPrice(String symbol) {
        try {
            log.info("Fetching stock price for {}", symbol);

            String url = UriComponentsBuilder.fromHttpUrl("https://www.alphavantage.co/query")
                    .queryParam("function", "TIME_SERIES_INTRADAY")
                    .queryParam("symbol", symbol)
                    .queryParam("interval", "5min")
                    .queryParam("apikey", apiKey)
                    .toUriString();

            Map<String, Object> response = restTemplate.getForObject(url, Map.class);

            if (response == null || !response.containsKey("Time Series (5min)")) {
                log.error("Invalid response from Alpha Vantage API: {}", response);
                return;
            }

            Map<String, Object> timeSeries = (Map<String, Object>) response.get("Time Series (5min)");
            String latestTimestamp = timeSeries.keySet().iterator().next();
            Map<String, String> latestData = (Map<String, String>) timeSeries.get(latestTimestamp);

            BigDecimal price = new BigDecimal(latestData.get("1. open"));
            log.info("Stock fetched: Symbol={}, Price={}", symbol, price);

            stockData.computeIfAbsent(symbol, k -> new ConcurrentLinkedQueue<>()).add(new StockDTO(symbol, price, LocalDateTime.now()));

            if (stockData.get(symbol).size() > 10) {
                stockData.get(symbol).poll();
            }
        } catch (Exception e) {
            log.error("Error fetching stock price for {}: {}", symbol, e.getMessage());
        }
    }

    public List<StockDTO> getRecentStockPrices(String symbol) {
        return List.copyOf(stockData.getOrDefault(symbol, new ConcurrentLinkedQueue<>()));
    }
}
